---
title: "4章 Composerの使い方と仕組み"
free: true
---

# Composerとは

既に本書でも説明なしに利用していますが、ComposerとはPHPのパッケージ管理ツールです。その主な仕事は、「パッケージの管理」「オートローダーの提供」「タスクランナー」の3つに分けられます。

前章で説明したPSR-4も、クラス(ファイル)のオートローディングに関する規約です。そこで、主要な3つの機能の内、まずは「オートローダーの提供」についてComposerが果たす役割・機能を説明します。

# 主な機能1: オートローダーの提供

PHPでは、同一ファイル中に定義されているクラスや、読み込み(ロード)済みの他のファイルに定義されているクラスは事由に利用することが出来ます。そのためには、require(once)やincludeを利用することになります。これは、クラスだけではなく、インターフェイス・トレイト・列挙型・定数・関数についても同様です。
しかしながら、依存しているクラス等の要素を、ファイルごとに明示的な読み込み命令を記述していくけば、どんどんとコードが煩雑になっていきます。リファクタリングによってクラス名やファイル名が変更される度に影響箇所が多くなるのも、メンテナンス性を下げるでしょう。かといって、アプリケーションの起動時(bootstrap処理やフロントコントローラーにて)に全てのファイルを読み込んでおくのも冗長な感じがします。
「必要なタイミングで必ず明示的にファイルをロードするのが煩わしい」「先行的に読み込むのではなく遅延読み込みによって未ロードのクラスを解決したい」という要求が生じます。これを叶えるために、PHPはクラスのオートローディングの機能を提供します。

オートローディングとは、「クラスを使おうとして、見つからなかった時に、特定のルールに従って、使おうとしたクラスの定義されているファイルの読み込みを試みて補完する」というものです。この「特定のルール」を定義するのが、**オートローダー**です。
php.netの記述では、 _オートローダーを登録すれば、PHPがエラーで止まる前にクラスをロードする最後の チャンスが与えられます_ と説明されています。すなわち、_Class "XXX" not found_ というErrorを発生させる前に、オートローダーによるファイルの読み込みを試みます。それによってクラスの解決が実現されれば、Errorは発生しないということです。

https://www.php.net/manual/ja/language.oop5.autoload.php

それでは、Composerが提供するオートローダーとは、どのような機能を持っているのでしょうか？少し具体的に見ていきましょう。

なお、本章ではこれ以降、特に言及がない場合には「クラス」といった場合に「クラス(class)」「インターフェイス(interface)」「トレイト(trait)」「列挙型(enum)」といったオートローディングによる解決が可能な要素を指すものとします。

## Composerのオートローダー

Composerを利用するプロジェクトでは、次のようなコードスニペットに見覚えのある方も多いのではないでしょうか。

```php
require __DIR__ . '/vendor/autoload.php';
```

これがまさに、「Comopserの提供するオートローダーを利用する」ための処理です。
この場では詳細は割愛しますが、掻い摘んで説明すると「Composerの作成したオートローディング用のルールを読み込む」「読み込んだルールでオートローディングが実行されるように `spl_autoload_register()` で登録する」「遅延読み込みではなく先行読み込みが必要なファイルをその場で読み込む」という処理が行われています。

https://www.php.net/manual/ja/function.spl-autoload-register.php

### dump-autoloadコマンド

各種設定に沿って、(オートローディング用の設定を含む)オートローダーを生成するのが_dump-autoload_コマンドです。これは、`vendor/autoload.php` とそこから参照されるクラスマップ等のファイルを生成します。 `composer dump-autoload`と打つことで実行されます[^dumpautoload]。実際には、パッケージの更新やインストールを伴う他のコマンド(`require`や`install`、`update`など)の`post-install`フェーズでオートローダーの生成が自動的に行われるため、直接このコマンドを利用することは少ないかも知れません。

このコマンドには、いくつかのオプションがあります。

* `--optimize`
  * PSR-0/PSR-4形式の対応パッケージについても、静的なクラスマップを生成して利用するためのオプションです。これにより、指定ディレクトリ以下を動的に探索する処理を省略して、「クラス名=>ファイルパス」という形式の連想配列で指定されたクラスマップからオートローディングを実行可能になります。オートローダーの生成には多少の時間を要することになりますが、プロダクション環境などの、パフォーマンス向上を見込みたい環境での利用が見込まれています
* `--classmap-authoritative`
  * 静的なクラスマップ以外からのクラス名の解決を行わないようにするためのオプションです。PSR-0/PSR-4形式のオートローディングを利用しない場合には、このオプションによって無用な処理を端折ることができます。また、`--optimize`オプションを利用した場合には、理論的に「クラスマップを調べるだけで全てのクラスが解決される」状態になるため、`--classmap-authoritative`を利用したのに似た挙動となります(両方のオプションを同時に利用することも可能です)
* `--apcu`
  * (動的に)探索されたクラスとファイルパスの対応情報や、あるいは解決できなかったクラスの情報をAPCu上にキャッシュするためのオプションです。通常、静的なクラスマップ以外の「クラスと対応ファイルのパス」「解決できなかったファイル」はプロセスごとに保持されるため、Webリクエスト1回ごとに揮発することになります。`--apcu`オプションを有効にすることで、複数のリクエストにまたいで探索結果が再利用可能になるため、パフォーマンスの向上が見込まれます。また、APCuへの読み書きを行う際には、キー名にランダムなプリフィックスが付与されることになります[^apcu-prefix]。この値は、`dump-autoload`コマンド実行の際に生成されて`autoload_real.php`ファイル上で指定されるため、アプリケーションコードのデプロイ時にAPCuキャッシュをパージしなくても安全に動作する設計になっています。

その他のオプションについては、公式ドキュメントを参照してください。

https://getcomposer.org/doc/03-cli.md#dump-autoload-dumpautoload



[^dumpautoload]: `dump-autoload`以外にも、エイリアスとして`dumpautoload`が設定されています。そのため、`comopser dumpautoload`でも実行が可能です
[^apcu-prefix]: `--apcu-prefix`オプションを指定することで、APCu利用時に付与するプリフィックスを明示的に指定することも可能です

### サポートするオートローディング・ファイル読み込み(先行読み込み)

Composerはいくつかのタイプでファイルの読み込み・オートローディングをサポートしています。
これらは全て、`composer.json`中の`autoload`フィールドで定義されるものです。

https://getcomposer.org/doc/04-schema.md#autoload

現時点では、以下の4つのタイプが定義されています

1. PSR-4
2. PSR-0
3. Classmap
4. Files

最終的には、ルートパッケージ(`composer install`などを実行する際に直接読み込まれる`comopser.json`で定義されているパッケージ)中のautoloadフィールドと、直接・間接的に依存されるautoloadフィールドの設定をマージしたものが、`vendor/composer.json`とそこから読み込まれるファイルに反映されます。

それぞれの1つずつ見ていきましょう。

#### PSR-4

名前の通り、PSR-4の規約に沿った形で設置されているクラスをオートロードしていくための設定です。
PSR-4のオートローディングを利用するためには、対象のパッケージを「名前空間のプリフィックス」「パッケージルートへの相対パス」のkey-valueペアで指定していきます。(PSR-4そのものについての説明は、前章を参照してください)
先頭の`\`は無し、末尾の`\`は含めて指定します。また、JSONファイル内での記述となるために`\`のエスケープが必要となり、`\\`で単一の`\`を表すことにも注意してください。

例えば、CakePHPのAppスケルトンでは、以下のように指定されています。

```json
{
  "autoload": {
        "psr-4": {
            "App\\": "src/"
        }
    },
    "autoload-dev": {
        "psr-4": {
            "App\\Test\\": "tests/",
            "Cake\\Test\\": "vendor/cakephp/cakephp/tests/"
        }
    }
}
```

これにより、 `App\Controller\PagesController`を利用した際に`__DIR__ . _src/Controller/PagesController.php`が、`App\Test\TestCase\Controller\PagesControllerTest`を利用した際に`__DIR__ . tests/TestCase/Controller/PagesControllerTest.php`を自動的読み込めるよになるのです。

PSR-4のフィールドに指定された名前空間プリフィックスとパッケージのルートディレクトリの対応情報は、`vendor/composer/autoload_psr4.php`ファイル内に書き出されます。
以下にサンプルを示します。(おおよそのイメージを共有することが目的のため、実際のファイルから内容を改変しています)

```php
<?php

// autoload_psr4.php @generated by Composer

$vendorDir = dirname(__DIR__);
$baseDir = dirname($vendorDir);

return array(
    'Twig\\Extra\\Markdown\\' => array($vendorDir . '/twig/markdown-extra'),
    'Twig\\' => array($vendorDir . '/twig/twig/src'),
    'Symfony\\Polyfill\\Php81\\' => array($vendorDir . '/symfony/polyfill-php81'),
    'Symfony\\Polyfill\\Php73\\' => array($vendorDir . '/symfony/polyfill-php73'),
    'Psr\\SimpleCache\\' => array($vendorDir . '/psr/simple-cache/src'),
    'Psr\\Log\\' => array($vendorDir . '/psr/log/src'),
    'Psr\\Http\\Server\\' => array($vendorDir . '/psr/http-server-handler/src', $vendorDir . '/psr/http-server-middleware/src'),
    'Composer\\' => array($vendorDir . '/composer/composer/src/Composer'),
    'Cake\\Composer\\' => array($vendorDir . '/cakephp/plugin-installer/src'),
    'Cake\\Chronos\\' => array($vendorDir . '/cakephp/chronos/src'),
    'Cake\\' => array($vendorDir . '/cakephp/cakephp/src'),
    'App\\Test\\' => array($baseDir . '/tests'),
    'App\\' => array($baseDir . '/src'),
);

```



#### PSR-0

オートローディングに関する規約として、PSRにはもう1つの定義があります。それが、PSR-0です。
PSR-0は、PHP-FIGとその前身となるPHP Standards Groupにとって初めてまとめられた仕様・規約となります。そこから歴史が進んだ現在では、オートローディングに関してはPSR-4がデファクトスタンダードです。そのため、PSR-0は[非推奨となっており](https://github.com/php-fig/fig-standards/pull/341) 、新規に採用されることはほとんど無いでしょう。

現在でもメンテナンスが続いているライブラリでPSR-0を採用しているものとしては、PHPMDが挙げられます[^phpmd-current]

https://github.com/phpmd/phpmd/tree/2.13.0

[^phpmd-current]: 執筆当時のバージョンである2.13.0の話になります

歴史の長いライブラリやプロジェクト等ではPSR-0を採用していたり、Composerとしても機能をサポートしていることを踏まえ、本書でもPSR-0に触れていきます。

PSR-0についての正式な仕様は、次のページで確認できます。

https://www.php-fig.org/psr/psr-0/

 ざっくりとした特徴としては、

* 最上位の名前空間には、ベンダー名を設けること
* 2階層目以下の名前空間は、0個以上の任意のものを設けることが出来る
* クラス名(末端要素)に `_`を含めた場合、それはDIRECTORY SEPARATORとして扱われる

というものです。

PSR-4と比べると、

* 名前空間と、ディレクトリ・パスの構造が必ずしも一致しない
* ディレクトリを区切るために複数の方法を提供している

という特徴があります。

何故このような仕様になっているか、そしてPSR-4が求められるようになったのか？については、歴史にその答えを求める事ができます。

ここで深く触れることは避けますが、代わりに参考になるであろう文献をリファレンスします。

* [PSR\-4 Meta Document \- PHP\-FIG](https://www.php-fig.org/psr/psr-4/meta/)
  * PSR-4が生まれた経緯やPSR-0との比較、この標準が解決したい問題について触れられています
* [Towards A Package\-Oriented Autoloader](https://groups.google.com/g/php-fig/c/JdR-g8ZxKa8/m/6A2-YDYaIiAJ)
  * PSR-0の課題を克服するための標準についての議論で、PSR-4の策定に繋がります
  * このスレッドの件名通り、元々は「パッケージ志向のオートローダー」と呼んでいたことも、(PEAR時代の管理のあり方と比較して)興味深い点と言えるのではないでしょうか

それでは、PSR-0によるオートロードの設定について具体例を交えてみていきます。

以下のようなcomposer.jsonによる指定があったとします。

```json
{
    "autoload": {
        "psr-0": {
            "O0h\\Psr0App\\": "src-psr0",
            "O0h\\Psr0App2\\": "src-psr0"
        }
    }
}
```

この場合、Composerが生成する名前空間ベースのautoloadファイル(`autoload_namespace.php`)は次のようになります

```php
return array(
    'O0h\\Psr0App\\' => array($baseDir . '/src-psr0'),
    'O0h\\Psr0App2\\' => array($baseDir . '/src-psr0'),
);
```

PSR-4が「パッケージと名前空間の位置関係」を指定したのに対して、PSR-0では「パッケージ群が配置される(例えばベンダーごとの)ディレクトリ」を指定するようなイメージです。
そのため、(この例でいうと) `src-psr0` + `vendor(O0h) / package(Psr0App, Psr0App2)`というディレクトリの用意が必要です。

これに対応させるためには次のようにファイルを設置します

| path                                          | FQCN                               |
| --------------------------------------------- | ---------------------------------- |
| ./src-psr0/O0h/Psr0App/Application.php        | O0h\Psr0App\Application            |
| ./src-psr0/O0h/Psr0App/Models/UserModel.php   | O0h\Psr0App\Models_UserModel       |
| ./src-psr0/O0h/Psr0App2/Application2.php      | O0h\Psr0App2\Psr0App2\Application2 |
| ./src-psr0/O0h/Psr0App2/Models2/ItemModel.php | O0h\\Psr0App2\\Models2\\ItemModel  |

ディレクトリの区切り文字を意味する `_` をFQCNに利用していない場合(`Psr0App2`の例)、シームレスにPSR-4に移行することが出来ます。例えば、`O0h\Psr0App2\Models2\ItemModel`についていえば、適切にcomposer.jsonのautoloadフィールドを指定してしまえば、PSR-4としてでも動作可能です。

```json
{
    "autoload": {
        "psr-4": {
            "O0h\\Psr0App2\\": "src-psr0/O0h/Psr0App2"
        }
    }
}
```

PSR-4に適応させるには、ディレクトリに移動を伴う形での対応も可能ですし、見た目的にはこちらの方が自然になることでしょう。`./src-psr0/O0h/Psr0App2/` を `./src-psr0` に移動して、composer.jsonの定義を以下のように書き換えます。

```json
{
    "autoload": {
        "psr-4": {
            "O0h\\Psr0App2\\": "src-psr0/"
        }
    }
}
```



実際にPSR-0からPSR-4に移行した例としては、Behatのv3.6.0での変更を挙げることが出来ます。
この例では、ディレクトリの変更を伴わずにオートロードの方式だけを変更しています。
こうした実例を見ることで、PEAR的な世界観・PSR-0時代の世界観・PSR-4時代の世界観、というのが地続きに変化してきたことが感じられるのではないでしょうか。

https://github.com/Behat/Behat/pull/1170

#### Classmap

PSR-0/PSR-4が、ルールベースの名前解決を提供するのに対して、Classmapでのオートロードは、クラスファイルの位置を自明に扱うことによって解決手段を提供します。すなわち、「事前にクラスファイルとクラス名をクラスマップとして書き出しておき、Comoserのオートローダーは、その対応表を参照する」ような挙動です。

まず、composer.json上にクラスマップの作成対象とするパス(ディレクトリでもファイルでも可)ディレクトリを指定します。

```composer.json
{
		"autoload": {
        "classmap": [
            "src-classmap"
        ]
    }
}
```

すると、対象のパス配下に含まれるファイルを操作して、ファイル名・FQCNの対応表が作成されます。それが、`vendor/composer/autoload_classmap.php` として書き出されます。

以下は、実際に作成されたautoload_classmap(を一部改変したもの)です。namespaceやpathに規則性がなく、事前知識なしにはクラス名からファイルの配置位置を推測するのが難しいのではないでしょうか。


```php
<?php

$vendorDir = dirname(__DIR__);
$baseDir = dirname($vendorDir);

return array(
    'O0h\\SomeClass' => $baseDir . '/src-classmap/SubDirectory/NameSpacePrefixedClass.php',
    'OtherClass' => $baseDir . '/src-classmap/SubDirectory/OtherClass.php',
    'SomeClass' => $baseDir . '/src-classmap/SomeClass.php',
);

```

あるいは、namespaceのprefixが付与されていないクラスをオートロードさせたいときにも、Classmapによる指定が有効です(こうしたテクニックはpolyfillのためにルートの名前空間に要素を設置したい場合などに用いることがあります)。

#### Files

5つあるComposerのオートロード形式のうち、最後が `Files`です。

この形式だけは、他の4つとは機能面で大きく異なっています。他のタイプが「利用したクラスが読み込まれていなかった時に、対象ファイルを探しに行く(PHPの[クラスのオートローディング](https://www.php.net/manual/ja/language.oop5.autoload.php#language.oop5.autoload)機能を利用するもの)」のに対して、Filesはアプリケーションによるクラスの利用の有無に関わらず、先行的に指定されたファイルを読みに行きます。
これにより、設定ファイルや関数定義といった、クラスとは関係のないものを読み込んでおくことができるのです。

設定は、`files` フィールドに対象ファイルをリストで指定することで完了します。
実例として、CakePHPの例を挙げてみましょう。

https://github.com/cakephp/cakephp/blob/4.4.2/composer.json#L81-L87

ご覧のように、関数を定義している `functions.php`や初期設定を行う`bootstrap.php`といった内容が記述されています。

なお、読み込まれる順位としては、「自分自身が依存している(`files`に指定している)ファイル」よりも「自分の依存先のパッケージが依存しているファイル」の方が先となり、自身の指定しているファイルは最後に読み込まれることになります。
そのため、もし明示的にあらゆるパッケージの依存ファイルよりも先行して処理させたい需要がある場合は、`vendor/autoload.php`よりも先に読み込む必要があります。



# 主な機能2: パッケージの管理

:::message
この節は未作成です
:::

※ この節には、以下の内容を含む予定です

* require 
* install
* update
  * --with
  * --lock
* remove
* create-project
* show
* depends / prohibits

## PackagistとComposer

# 主な機能3: タスクランナー

:::message
この節は未作成です
:::

# その他の機能

:::message
この節は未作成です
:::

## exec

## audit

## status

## check-platform-reqs

## キャッシュについて



