---
title: "├ W-③: STEP-1 PSR-4クラスマップの作成"
---

# STEP-1 PSR-4名前空間マップの作成

## A. 課題について

### 背景

PSR-4のねらいは、ざっくりと言えば「名前空間とディレクトリ階層、クラスメイトファイル名が一致している」ことを前提としたオートローディングの戦略です。これにより、PHPが「読み込まれていない(存在しない)クラス」を利用した際にクラスファイルの在処を推測し、読み込むような仕掛けとなっています。

https://www.php-fig.org/psr/psr-4/

ただし「1番最上位の名前空間が、どこにディレクトリに対応しているのか」については、ロジックだけでは解決できません。この部分に関しては、外部からの知識(設定)の注入によって補っています。

例えば、`guzzlehttp/guzzle` をインストールした際に生成される名前空間マップは以下のとおりです。

```php
<?php

// autoload_psr4.php @generated by Composer

$vendorDir = dirname(__DIR__);
$baseDir = dirname($vendorDir);

return array(
    'Psr\\Http\\Message\\' => array($vendorDir . '/psr/http-factory/src', $vendorDir . '/psr/http-message/src'),
    'Psr\\Http\\Client\\' => array($vendorDir . '/psr/http-client/src'),
    'GuzzleHttp\\Psr7\\' => array($vendorDir . '/guzzlehttp/psr7/src'),
    'GuzzleHttp\\Promise\\' => array($vendorDir . '/guzzlehttp/promises/src'),
    'GuzzleHttp\\' => array($vendorDir . '/guzzlehttp/guzzle/src'),
);    
```

これは、`Psr\\Http\\Client\\` から始まるクラスであれば `/psr/http-client/src'`以下に格納されていることを示しています。これより下位の名前空間については、PSR-4の命名規則に従って解決するものです。

また、この設定内容は各パッケージの `composer.json` 内にある `autoload(-dev).psr-4` フィールドの設定のコピーです。

**CakePHPのcomposer.jsonの例(一部割愛)**

```json
"autoload": {
    "psr-4": {
        "Cake\\": "src/"
    },
},
"autoload-dev": {
    "psr-4": {
        "Cake\\PHPStan\\": "tests/PHPStan/",
        "Cake\\Test\\": "tests/",
        "TestApp\\": "tests/test_app/TestApp/",
        "TestApp\\Test\\": "tests/test_app/TestApp/tests/",
        "TestPlugin\\": "tests/test_app/Plugin/TestPlugin/src/",
        "TestPlugin\\Test\\": "tests/test_app/Plugin/TestPlugin/tests/",
        "TestPluginTwo\\": "tests/test_app/Plugin/TestPluginTwo/src/",
        "Company\\TestPluginThree\\": "tests/test_app/Plugin/Company/TestPluginThree/src/",
        "Company\\TestPluginThree\\Test\\": "tests/test_app/Plugin/Company/TestPluginThree/tests/",
        "Named\\": "tests/test_app/Plugin/Named/src/"
    }
},
```

ということで！我々も、PSR-4の名前空間マップを作ってみましょう！

### 課題

|                | コンテナ内のパス                         |
| -------------- | ---------------------------------------- |
| 作業用ファイル | `/opt/work/3_dump-autoload/step1.php`    |
| 実装サンプル   | `/opt/example/3_dump-autoload/step1.php` |

step1.phpにある`procedure3_1` 関数を完成させていきます。
「`vnedor`ディレクトリ配下にある`comopser.json`のパスを一覧化しました」というところから、今回の課題が始まります。

1. `composer.json` を読み込んでパッケージ情報を解釈し、`autoload.psr-4`の内容を取得する
   * 存在しなければcontinue
2. 取得した内容から、名前空間とディレクトリを対応付けるマップを作成する
   * `{namespace: directory_path[]}`の形式

本来はこの後に、作成したマップを指定箇所にファイルとして出力する処理があります。これは、「連想配列を1つ返すPHPスクリプト」として記述されています。
このハンズオンでは既に「実装済み」として編集(作成)がいらない部分としました。もし興味があったら、「 STEP-1 ココまで」の後に続くコードも読んでみてください

### 参考: 関連の深いComposerのファイル・コード

* https://github.com/composer/composer/blob/2.8.3/src/Composer/Repository/InstalledRepository.php
  * 本来であれば、「インストール済みのパッケージ」を扱う仕組みはこのようになっている
* https://github.com/composer/composer/blob/2.8.3/src/Composer/Autoload/AutoloadGenerator.php#L278-L288
  * PSR-4のマップを作成している部分

## B. 実装例とコードの解説

作業前のファイルの全景

```php
<?php
processDumpAutoload(__DIR__ . '/vendor'); // この内部で `procedure3_1` が呼ばれます

function procedure3_1 (string $vendorDirPath): string
{
    $psr4ClassMap = [];
    $packageFiles = glob("{$vendorDirPath}/*/*/composer.json");
    foreach ($packageFiles as $packageFile) {
        /* === STEP-1 ココから === */



        /* === STEP-1 ココまで === */
    }

    $psr4ClassMapPath = $vendorDirPath . '/autoload_classmap_psr4.php';
    file_put_contents(
        $psr4ClassMapPath,
        '<?php return '.var_export($psr4ClassMap, true).';'
    );

    return $psr4ClassMapPath;
}
```

### 1. `composer.json` を読み込んでパッケージ情報を解釈し、`autoload.psr-4`の内容を取得する

ここも例によって `file_get_contents` `json_decode` もしくは `loadJsonFile` に活躍してもらう場面です。
読み取った後に、目的のフィールドの読み込み(or存在しなければループ処理をcontinue)を愚直に行います

```php
<?php
processDumpAutoload(__DIR__ . '/vendor'); // この内部で `procedure3_1` が呼ばれます

function procedure3_1 (string $vendorDirPath): string
{
    $psr4ClassMap = [];
    $packageFiles = glob("{$vendorDirPath}/*/*/composer.json");
    foreach ($packageFiles as $packageFile) {
        /* === STEP-1 ココから === */


        $package = json_decode(file_get_contents($packageFile), true);
        $packagePsr4ClassMaps = $package['autoload']['psr-4'] ?? null;
        if (!$packagePsr4ClassMaps) {
            continue;
        }

        // ココから追記
        $packageDir = dirname($packageFile);

        foreach ($packagePsr4ClassMaps as $namespace => $dirName) {
            if (!array_key_exists($namespace, $psr4ClassMap)) {
                $psr4ClassMap[$namespace] = [];
            }
            $psr4ClassMap[$namespace][] = rtrim("{$packageDir}/{$dirName}", '/');
        }
        // ココまで追記



        /* === STEP-1 ココまで === */
    }

    $psr4ClassMapPath = $vendorDirPath . '/autoload_classmap_psr4.php';
    file_put_contents(
        $psr4ClassMapPath,
        '<?php return '.var_export($psr4ClassMap, true).';'
    );

    return $psr4ClassMapPath;
}
```

### 2. 取得した内容から、名前空間とディレクトリを対応付けるマップを作成する

PSR-4において、namespaceと実際のディレクトリのパスの関係は、1:1ではなく1:Nになっていることに気をつけてください。

また、紐づけるパスは「`composer.json`に書かれているパス」だけでなく、「そのディレクトリがある場所所までのパス」も必要です。

たとえば`sugoi/iikanji`というパッケージがあり、そのPSR-4名前空間マップが次のようになっていた場合

```json
{"autoload": {"psr-4": {"SugoiOrg\\Iikanji\\": ["src/"]}}
```

出力する名前空間マップは、

```json
{ "SugoiOrg\\Iikanji\\": ["/path/to/project/root/vendor/sugoi/iikanji/src/"] } 
```

にしなければなりません。[^original-composer-kashikosa]

[^original-composer-kashikosa]:本物のComposerでもパスの指定は絶対パスで行っていますが、`vendor/`までの文字列は動的にとるようになっています。

```php
<?php
processDumpAutoload(__DIR__ . '/vendor'); // この内部で `procedure3_1` が呼ばれます

function procedure3_1 (string $vendorDirPath): string
{
    $psr4ClassMap = [];
    $packageFiles = glob("{$vendorDirPath}/*/*/composer.json");
    foreach ($packageFiles as $packageFile) {
        /* === STEP-1 ココから === */
        $package = json_decode(file_get_contents($packageFile), true);
        $packagePsr4ClassMaps = $package['autoload']['psr-4'] ?? null;
        if (!$packagePsr4ClassMaps) {
            continue;
        }

        // ココから追記
        $packageDir = dirname($packageFile);

        foreach ($packagePsr4ClassMaps as $namespace => $dirName) {
              if (!array_key_exists($namespace, $psr4ClassMap)) {
                  $psr4ClassMap[$namespace] = [];
              }
              $psr4ClassMap[$namespace][] = rtrim("{$packageDir}/{$dirName}", '/');
        }
        // ココまで追記



        /* === STEP-1 ココまで === */
    }

    $psr4ClassMapPath = $vendorDirPath . '/autoload_classmap_psr4.php';
    file_put_contents(
        $psr4ClassMapPath,
        '<?php return '.var_export($psr4ClassMap, true).';'
    );

    return $psr4ClassMapPath;
}
```



---

STEP-X1はコレで完了です。

終わったら、課題の内容をクリアする実装ができているかを確認しましょう。
用意されている`make` コマンドで検査できます。コンテナ内ではなく、コンテナの外側（ホストマシン）で実行することに注意してください。

**ホストから**

```
make work3
```

もし`make`が使えないなど、コンテナ内で行う場合には下記のコマンドを利用してください。

**コンテナ内で**

```sh
php /opt/work/3_dump-autoload/main.php
```

『✅ StepXが完了しました！』と出力されていれば、成功です。自信を持って、次のステップに進みましょう！
ついでに、`work/3_dump-autoload/vendor/autoload_classmap_psr4.php` の内容を覗いてみるのも楽しいと思います。

![](/images/4_work3_2_step1/finish.gif)
