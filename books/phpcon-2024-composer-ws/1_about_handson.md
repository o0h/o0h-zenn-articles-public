---
title: "ハンズオンの進め方"
---

## ハンズオンのゴール

「はじめに」で述べたように、本書で題材とするのは「Composerの `require`コマンドを再発明」です。ハンズオン形式になっていて、小さい単位に分解された課題に1つずつ取り組んでいきます。最終的には、「パッケージを追加して、含まれているクラスをオートローディングできる」状態を目指します。

### 具体的な制作物

一言で `require` といっても、いくつもの仕事が含まれています。少し具体的に見ていましょう。

**何もないところに、新しくパッケージを追加する例**

大まかに概念を整理すると、`require`は次のような仕事となります。

1. CLIからコマンドを実行 (例: `composer require nyholm/psr7`)
2. Packagistへレポジトリのメタ情報を問い合わせ (URL: `https://packagist.org/packages.json`)
3. 取得したメタ情報を使って、パッケージのメタ情報を取得 (URL: `https://repo.packagist.org/p2/nyholm/psr7.json`)
4. パッケージのメタ情報を使って、提供されているバージョンや依存内容、動作に必要な要件を取得
5. `compoer.json` ファイルの作成
6. 依存関係の整理と、各パッケージについて最終的に利用するバージョンの解決
7. `composer.lock`ファイルの作成
8. 各パッケージのコンテンツを取得
9. 取得したコンテンツを `vendor`ディレクトリに配置
10. 配置したパッケージをオートローディング可能にする(`autoload.php`の作成など)

かなり端折った書き方ですが、大凡のイメージとしては間違っていないでしょう。多岐にわたるタスクが処理されています。

これを一気通貫で扱おうと考えると、とても大変そうですよね。このハンズオンでは、いくつかのフェーズに分割して実装してきます。

実際にComposerが提供しているコマンドや `require`の内部実装を踏まえて、次のようにグルーピングしました。

**requireを3つのフェーズに分割**

1. requireフェーズ
   - 内容: 新規にパッケージを追加する仕事
   - アウトプット: `composer.json` `composer.lock`の作成
2. installフェーズ
   - 内容: `composer.lock`を読み取り、パッケージを取得する仕事
   - アウトプット: `vendor`ディレクトリ以下へのパッケージコンテンツの配置
3. dump-autoloadフェーズ
   - 内容: インストール済みパッケージを、オートロード可能にする仕事
   - アウトプット: `autoload.php`と関連ファイルの作成

フェーズ1つごとに、1つのツールを仕上げていく形式とします。

![](/images/1_about_handson/1/separate-tasks.png)
*requireを3つのフェーズで捉える*

なお、実際のComposerに比べると、多くの機能や柔軟性が削ぎ落とされたものとなります。あくまで学習用ということで、「Composerのエッセンスに触れる」のを優先するためです。
その代わりに、「実際のComposerのコードでいうと、この部分に対応する」という情報(GitHub上のURL)を積極的に示していきます。興味が湧いた際には、より本格的な理解のため是非とも覗いてみてください！

## ハンズオンの流れ(本書の構成)

序盤に「ハンズオン全体の流れ(本頁)」「環境構築」を含みますが、その後は本格的にハンズオンが始まります。

3つに分割したフェーズを、それぞれ「ワーク」と題しています。ワークはそれぞれ独立しているので、順番を気にせずに取り組めます。

ワークの中は、更に「ステップ」に分割されています。ステップごとに「課題」が提示されているので、その条件に合うようにコードを書いていく事になります。あるステップに取り組むには、その前のステップをすべて完了していることが条件になります。そのため、ステップ1から順番に取り組む必要があります。

ステップごとに、「A. 課題について」「B.実装例とコードの解説」に分かれています。
Aパートでは、Composerの仕組みを説明と織り交ぜて「ハンズオンとして取り組む課題(=実装課題)」を取り扱います。Bパートでは、課題に則って書いたコードの解説になります。すなわち、Aパートまでは「ネタバレなし」で読めるようになっています。Composerの内部的な仕組みに触れるという点では、Aパートこそが本丸と言えます。一方で、ハンズオンとして「コードを書いて楽しむ」という点ではBパートこそメインです。どちらも楽しんでください！

ちなみに、今後の展開として、各ワークの最後に「エクササイズ」も用意しようと考えています。それぞれのワークに応じた内容を、改めて実装してみよう！というものです。
各ステップは、良くも悪くも「予め細かく分割されている」と考えます。その弊害で、全体的な流れを実感しにくい面もあるでしょう。それよりも、もっと純粋に「動くツールを作る」ことを感じられる楽しみもあるはずです。エクササイズは、この欲求を満たす場所となります。各ステップをこなして掴んだ「エッセンス」を糧にして、ゼロベースで「本当に動くもの」を作っててみてください！

![](/images/1_about_handson/1/outline.png)
*本書の基本的な構成*

## ハンズオンの進め方

ハンズオン用の資料はGItHubに公開されてますので、次頁の環境構築手順を参考に取得してください。

ステップごとに「作業用ファイル」が用意されています。(例: `work/2_require/step1.php`、`work/2_require/step2.php`、・・)
これらのファイルには、虫食い形式で「ココから」「ココまで」が記されています。指示された課題に沿って、虫食い部分を埋めていこうというのがハンズオンで取り組む内容です。

**参考イメージ**

```php
$requirePackageNameList = ['aura/cli', 'psr/log'];

foreach ($requirePackageNameList as $requirePackageName) {
    processRequirePackage($requirePackageName); // この内部で `procedure2_2` が呼ばれます
}

function procedure2_2(string $packageVersionedMetaList): array
{
    /* === STEP-2 ココから === */
    
    
    
    /* === STEP-2 ココまで === */
}
```

実装が終わったら、タスクランナーから「ワーク内容の実行」を行います。Makefileにまとめてあるので、例えばワーク2であれば次のようなコマンドを叩きます。

```sh
make work2
```

これによってワークごとの(=全ステップを通した)処理が起動される形です。うまくいくと、次のように「COMPLETE」表示を確認できます！

```sh
sh-3.2$ make work2
docker compose run --rm app php /opt/work/2_require/main.php
🐘WORK START🐘
WORK2:   require

---Begin Set Up---


---Finished Set Up---

🤾      Step1を開始します...
✅       Step1が完了しました！
🤾      Step2を開始します...
✅       Step2が完了しました！
🤾      Step3を開始します...
✅       Step3が完了しました！
🤾      Step4を開始します...
✅       Step4が完了しました！

💯 WORK COMPLETE 💯

```

もし実装内容が課題の要件を満たしていない場合は、その旨が表示されます。自己診断的なメッセージが用意されています。

```sh
sh-3.2$ make work2
docker compose run --rm app php /opt/work/2_require/main.php
🐘WORK START🐘
WORK2:   require

---Begin Set Up---


---Finished Set Up---

🤾      Step1を開始します...
✅       Step1が完了しました！
🤾      Step2を開始します...
✅       Step2が完了しました！
🤾      Step3を開始します...
====
【Step3】の内容を正しく実装できていなそうです。コードを見直してみてください！
💡 正しく動作しない原因が、もっと手前のステップにある場合もあります。
----
失敗理由:       psr/log の情報がcomposer.jsonに書き込めていなそうです
ファイルパス:   work/2_require/step3.php
====
make: *** [work2] Error 1
```

「課題を読む → 課題を解いて実装をする → チェックコマンドを実行する」のサイクルを繰り返しながら、全てのWORKをクリアしていきましょう。

なお、エクササイズについては診断用プログラムは用意されていません。